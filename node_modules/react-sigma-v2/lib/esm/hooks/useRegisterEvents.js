"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useRegisterEvents = void 0;
const react_1 = require("react");
const useSigma_1 = require("./useSigma");
const useSetSettings_1 = require("./useSetSettings");
const sigmaEvents = [
    "clickNode",
    "rightClickNode",
    "downNode",
    "enterNode",
    "leaveNode",
    "doubleClickNode",
    "wheelNode",
    "clickEdge",
    "rightClickEdge",
    "downEdge",
    "enterEdge",
    "leaveEdge",
    "doubleClickEdge",
    "wheelEdge",
    "clickStage",
    "rightClickStage",
    "downStage",
    "doubleClickStage",
    "wheelStage",
    "kill",
];
const mouseEvents = [
    "click",
    "rightClick",
    "mouseup",
    "mousedown",
    "mousemove",
    "doubleClick",
    "wheel",
];
const touchEvents = ["mouseup", "mousedown", "mousemove"];
const cameraEvents = ["cameraUpdated"];
function useRegisterEvents() {
    const sigma = useSigma_1.useSigma();
    const setSettings = useSetSettings_1.useSetSettings();
    const [eventHandlers, setEventHandlers] = react_1.useState({});
    react_1.useEffect(() => {
        if (!sigma || !eventHandlers) {
            return;
        }
        const eventTypes = Object.keys(eventHandlers);
        const edgeSettings = {};
        const reverseEdgeSettings = {};
        const sigmaSettings = sigma.getSettings();
        if (eventTypes.some(event => ["clickEdge", "rightClickEdge", "doubleClickEdge", "downEdge"].includes(event)) &&
            sigmaSettings.enableEdgeClickEvents === false) {
            edgeSettings["enableEdgeClickEvents"] = true;
            reverseEdgeSettings["enableEdgeClickEvents"] = false;
        }
        if (eventTypes.some(event => ["enterEdge", "leaveEdge"].includes(event)) &&
            sigmaSettings.enableEdgeHoverEvents === false) {
            edgeSettings["enableEdgeHoverEvents"] = true;
            reverseEdgeSettings["enableEdgeHoverEvents"] = false;
        }
        if (eventTypes.some(event => ["wheelEdge"].includes(event)) && sigmaSettings.enableEdgeWheelEvents === false) {
            edgeSettings["enableEdgeWheelEvents"] = true;
            reverseEdgeSettings["enableEdgeWheelEvents"] = false;
        }
        if (Object.keys(edgeSettings).length > 0) {
            setSettings(edgeSettings);
        }
        eventTypes.forEach((event) => {
            const eventHandler = eventHandlers[event];
            if (sigmaEvents.includes(event)) {
                sigma.on(event, eventHandler);
            }
            if (mouseEvents.includes(event)) {
                sigma.getMouseCaptor().on(event, eventHandler);
            }
            if (touchEvents.includes(event)) {
                sigma.getTouchCaptor().on(event, eventHandler);
            }
            if (cameraEvents.includes(event)) {
                sigma.getCamera().on("updated", eventHandler);
            }
        });
        return () => {
            let event;
            if (Object.keys(reverseEdgeSettings).length > 0) {
                setSettings(reverseEdgeSettings);
            }
            for (event in eventHandlers) {
                const eventHandler = eventHandlers[event];
                if (sigmaEvents.includes(event)) {
                    sigma.removeListener(event, eventHandler);
                }
                if (mouseEvents.includes(event)) {
                    sigma.getMouseCaptor().removeListener(event, eventHandler);
                }
                if (touchEvents.includes(event)) {
                    sigma.getTouchCaptor().removeListener(event, eventHandler);
                }
                if (cameraEvents.includes(event)) {
                    sigma.getCamera().removeListener("updated", eventHandler);
                }
            }
        };
    }, [sigma, eventHandlers, setSettings]);
    return setEventHandlers;
}
exports.useRegisterEvents = useRegisterEvents;
//# sourceMappingURL=useRegisterEvents.js.map